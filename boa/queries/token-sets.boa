o: output collection[proj: string][path: string] of tokens: string;

{@escape@}

tokens: set of string;
tokenCounts: map[string] of int;

getcount := function(v: string): string {
    if (tokenCounts[v] > 1)
        return string(tokenCounts[v]) + ":";
    return "";
};

maybehash := function(s: string): string {
    h := "#" + string(hash(s));
    if (len(h) < len(s)) return h;
    if (substring(s, 0, 1) == "\"") return h;
    if (strfind(":", s) > -1) return h;
    return s;
};

tokensToString := function(tokens: set of string): string {
    s := "";
    vals := values(tokens);
    foreach (i: int; len(vals[i]) > 0)
        s += getcount(vals[i]) + maybehash(vals[i]) + ",";
    return escape(substring(s, 0, len(s) - 1));
};

addToken := function(t: string) {
    if (!def(t) || len(t) == 0) return;
    add(tokens, t);
    tokenCounts[t] = lookup(tokenCounts, t, 0) + 1;
};

{@project-filter@}
visit(input, visitor {
	before cr: CodeRepository -> {
		snapshot := getsnapshot(cr, "SOURCE_");
		foreach (i: int; def(snapshot[i]))
			visit(snapshot[i]);
		stop;
	}
	before cf: ChangedFile -> {
		if (match(`_ERROR$`, string(cf.kind)))
			stop;
        clear(tokens);
    }
    after cf: ChangedFile ->
        if (len(tokens) > 20)
    		o[input.id][escape(cf.name)] << tokensToString(tokens);

    before d: Declaration -> addToken(d.name);
    before v: Variable    -> addToken(v.name);
    before m: Method      -> if (def(m.name)) addToken(m.name);
    before e: Expression  -> if (e.kind == ExpressionKind.LITERAL) addToken(e.literal);
});